

1.  Response Capture Strategy is Viable: The expo-share-extension GitHub repository confirms that creating an iOS share extension with Expo is fully supported. This is the most reliable method for capturing LLM app responses, as it allows your proxy app to appear directly in the system share sheet.
    *   It's compatible with Expo SDK 54, aligning with your note about performance gains.
    *   The library provides methods to receive shared text and url data and to close the extension or openHostApp programmatically‚Äîexactly what you need to automate the workflow.

2.  USB Connectivity is Practical: The Qubes OS forum discussion provides a real-world, step-by-step guide for the exact USB reverse tethering setup you mentioned (adb reverse).
    *   The process involves enabling USB debugging on the Android device, using adb to establish a connection, and running gnirehtet to provide internet to the phone over USB.
    *   This validates your plan to use USB as a low-latency, reliable fallback to WiFi.

üõ†Ô∏è Recommended Development Path (Weeks 1 & 2)

You can immediately start building using these validated components. Here is a focused integration plan:

Phase 1: Build the Core Proxy with Share Extension

¬∑ Action: Start your Expo project and integrate expo-share-extension as your primary response handler.
¬∑ How-to: Follow the "Quick Start" in the GitHub repo. Your ShareExtension component will receive the text response from other apps. Your main task is to modify it to immediately forward this text to your desktop (via your HTTP server) and then auto-close.
¬∑ Key Config: In your app.json, set the activationRules to support text and url. This ensures your proxy appears when sharing from LLM apps.

Phase 2: Implement USB Reverse Tethering Fallback

¬∑ Action: Set up the USB connection method as an alternative to mDNS/WiFi.
¬∑ How-to (Android):
  1. Enable Developer Options and USB Debugging on your phone.
  2. Connect via USB and authorize the connection: adb devices
  3. Set up reverse port forwarding: adb reverse tcp:8080 tcp:8080. This forwards your phone's port 8080 to your desktop's port 8080.
  4. Your desktop client can now connect to http://localhost:8080 directly, eliminating network discovery.
¬∑ For Internet on Phone: Use gnirehtet as outlined in the forum to share your desktop's internet connection with the phone over USB.

Note on Other Sources:

¬∑ The Arch Linux wiki page on Android tethering was not accessible.
¬∑ The Reddit link on clipboard polling returned an access error. However, your research correctly identifies clipboard polling as a less ideal fallback due to battery impact. The share extension method is superior and confirmed to work.

üöÄ Suggested Immediate Next Steps

1. Initialize Your Expo Project: Run npx create-expo-app llm-proxy-bridge and install expo-share-extension.
2. Create the Share Extension Entry Point: Set up the basic index.share.js to log received text. Test that it appears in the share menu from your notes app.
3. Merge the HTTP Server Code: Integrate your research's server code (createServer) into the main app to listen for requests from your desktop.
4. Test the USB Connection: Before writing complex desktop code, use adb reverse and a simple browser or curl command to send a test POST request from your desktop to localhost:8080 and see if it reaches your phone.

Your project foundation is very strong. The next phase is hands-on integration of these proven pieces.

If you run into specific issues while setting up the Expo share extension or the adb USB workflow, feel free to ask for more detailed guidance on those steps.

Excellent validation and prioritization! Let me provide **actionable implementation code** with the validated components, focusing on the immediate next steps you've outlined.

## Phase 1: Core Expo Proxy with Share Extension

### Step 1: Initialize Project

```bash
# Create Expo project with Router
npx create-expo-app@latest llm-proxy-bridge --template tabs
cd llm-proxy-bridge

# Install dependencies
npx expo install expo-share-intent expo-linking expo-clipboard expo-network
npm install bonjour-service express
```

### Step 2: Configure Share Extension (app.json)

```json
{
  "expo": {
    "name": "LLM Proxy Bridge",
    "slug": "llm-proxy-bridge",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "scheme": "llmproxy",
    "plugins": [
      [
        "expo-share-intent",
        {
          "iosActivationRules": {
            "NSExtensionActivationSupportsText": true,
            "NSExtensionActivationSupportsWebURLWithMaxCount": 1,
            "NSExtensionActivationSupportsWebPageWithMaxCount": 1
          },
          "androidIntentFilters": [
            "text/plain",
            "text/*"
          ],
          "androidMainActivityAttributes": {
            "android:launchMode": "singleTask"
          }
        }
      ]
    ],
    "ios": {
      "bundleIdentifier": "com.yourusername.llmproxybridge",
      "supportsTablet": true,
      "infoPlist": {
        "UIBackgroundModes": ["fetch", "processing"]
      }
    },
    "android": {
      "package": "com.yourusername.llmproxybridge",
      "permissions": [
        "INTERNET",
        "ACCESS_NETWORK_STATE",
        "ACCESS_WIFI_STATE"
      ]
    }
  }
}
```

### Step 3: Share Extension Entry Point (index.share.tsx)

```typescript
// index.share.tsx - Share extension handler
import { Text, View, StyleSheet } from 'react-native';
import { useShareIntent } from 'expo-share-intent';
import { useEffect } from 'react';
import { useRouter } from 'expo-router';

export default function ShareExtension() {
  const { shareIntent, resetShareIntent, hasShareIntent } = useShareIntent({
    debug: true,
    resetOnBackground: true,
  });
  const router = useRouter();

  useEffect(() => {
    if (!hasShareIntent) return;

    const handleShare = async () => {
      try {
        // Extract text from share intent
        const sharedText = shareIntent.text || shareIntent.webUrl || '';
        
        if (sharedText) {
          // Forward to main app with response
          console.log('Received share:', sharedText);
          
          // Store in app state for HTTP server to retrieve
          await storeResponse(sharedText);
          
          // Auto-close share extension after 1s
          setTimeout(() => {
            resetShareIntent();
            router.replace('/'); // Return to main app
          }, 1000);
        }
      } catch (error) {
        console.error('Share handling error:', error);
      }
    };

    handleShare();
  }, [hasShareIntent, shareIntent]);

  return (
    <View style={styles.container}>
      <Text style={styles.text}>Processing response...</Text>
      <Text style={styles.subtext}>Sending to desktop</Text>
    </View>
  );
}

async function storeResponse(text: string) {
  // Store in AsyncStorage or global state
  // Will be retrieved by HTTP server when desktop polls
  const { default: AsyncStorage } = await import('@react-native-async-storage/async-storage');
  await AsyncStorage.setItem('latest_response', JSON.stringify({
    text,
    timestamp: Date.now()
  }));
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#1a1a1a',
  },
  text: {
    fontSize: 18,
    color: '#fff',
    fontWeight: '600',
  },
  subtext: {
    fontSize: 14,
    color: '#888',
    marginTop: 8,
  },
});
```

### Step 4: Main App with HTTP Server (app/(tabs)/index.tsx)

```typescript
// app/(tabs)/index.tsx
import { useState, useEffect } from 'react';
import { View, Text, StyleSheet, ScrollView, Switch } from 'react-native';
import * as Network from 'expo-network';
import AsyncStorage from '@react-native-async-storage/async-storage';
import express from 'express';
import bonjour from 'bonjour-service';

const APP_CONFIGS = {
  perplexity: { name: 'Perplexity', scheme: 'perplexity://query?q=' },
  chatgpt: { name: 'ChatGPT', scheme: 'chatgpt://chat?text=' },
  copilot: { name: 'Copilot', scheme: 'githubcopilot://prompt?q=' },
  claude: { name: 'Claude', scheme: 'claude://compose?text=' },
};

export default function HomeScreen() {
  const [serverStatus, setServerStatus] = useState('Stopped');
  const [ipAddress, setIpAddress] = useState('');
  const [lastRequest, setLastRequest] = useState('');
  const [usbMode, setUsbMode] = useState(false);
  const [app, setApp] = useState<any>(null);
  const [mdnsService, setMdnsService] = useState<any>(null);

  useEffect(() => {
    startServer();
    return () => {
      app?.close();
      mdnsService?.stop();
    };
  }, []);

  const startServer = async () => {
    try {
      // Get device IP
      const ip = await Network.getIpAddressAsync();
      setIpAddress(ip);

      // Create Express server
      const expressApp = express();
      expressApp.use(express.json());

      // Health check endpoint
      expressApp.get('/health', (req, res) => {
        res.json({ status: 'ok', timestamp: Date.now() });
      });

      // Query endpoint - Receive prompt from desktop
      expressApp.post('/query', async (req, res) => {
        const { appId, prompt, context } = req.body;
        setLastRequest(`${appId}: ${prompt.substring(0, 50)}...`);

        try {
          // Open target app via deep link
          const appConfig = APP_CONFIGS[appId as keyof typeof APP_CONFIGS];
          if (!appConfig) {
            return res.status(400).json({ error: 'Unknown app' });
          }

          const deepLink = appConfig.scheme + encodeURIComponent(prompt);
          const { default: Linking } = await import('expo-linking');
          await Linking.openURL(deepLink);

          // Store request ID for response matching
          await AsyncStorage.setItem('pending_request', JSON.stringify({
            appId,
            prompt,
            timestamp: Date.now()
          }));

          res.json({ 
            status: 'pending',
            message: 'App opened, waiting for share...'
          });
        } catch (error: any) {
          res.status(500).json({ error: error.message });
        }
      });

      // Poll endpoint - Desktop checks for response
      expressApp.get('/response', async (req, res) => {
        try {
          const stored = await AsyncStorage.getItem('latest_response');
          if (!stored) {
            return res.json({ status: 'pending' });
          }

          const response = JSON.parse(stored);
          
          // Clear after retrieval
          await AsyncStorage.removeItem('latest_response');
          
          res.json({
            status: 'complete',
            answer: response.text,
            timestamp: response.timestamp
          });
        } catch (error: any) {
          res.status(500).json({ error: error.message });
        }
      });

      // Start server
      const server = expressApp.listen(8080, () => {
        console.log(`Server running on ${ip}:8080`);
        setServerStatus('Running');
      });

      setApp(server);

      // Start mDNS advertisement
      const bonjourInstance = bonjour();
      const service = bonjourInstance.publish({
        name: 'LLM-Proxy-Bridge',
        type: 'llm-proxy',
        protocol: 'tcp',
        port: 8080,
        txt: {
          version: '1.0.0',
          apps: Object.keys(APP_CONFIGS).join(',')
        }
      });

      setMdnsService(service);
      console.log('mDNS service published');

    } catch (error) {
      console.error('Server start error:', error);
      setServerStatus('Error');
    }
  };

  return (
    <ScrollView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>üöÄ LLM Proxy Bridge</Text>
        <Text style={styles.subtitle}>Route desktop ‚Üí phone LLM apps</Text>
      </View>

      <View style={styles.card}>
        <Text style={styles.label}>Server Status</Text>
        <Text style={styles.value}>{serverStatus}</Text>
        
        <Text style={styles.label}>IP Address</Text>
        <Text style={styles.value}>{ipAddress || 'Loading...'}</Text>
        
        <Text style={styles.label}>Port</Text>
        <Text style={styles.value}>8080</Text>
      </View>

      <View style={styles.card}>
        <Text style={styles.label}>USB Mode (ADB Reverse)</Text>
        <Switch value={usbMode} onValueChange={setUsbMode} />
        {usbMode && (
          <Text style={styles.hint}>
            Desktop connects to: localhost:8080{'\n'}
            Run: adb reverse tcp:8080 tcp:8080
          </Text>
        )}
      </View>

      {lastRequest && (
        <View style={styles.card}>
          <Text style={styles.label}>Last Request</Text>
          <Text style={styles.value}>{lastRequest}</Text>
        </View>
      )}

      <View style={styles.card}>
        <Text style={styles.label}>Configured Apps</Text>
        {Object.entries(APP_CONFIGS).map(([id, config]) => (
          <Text key={id} style={styles.appItem}>
            ‚Ä¢ {config.name} ({id})
          </Text>
        ))}
      </View>

      <Text style={styles.footer}>
        Waiting for desktop requests...{'\n'}
        Share LLM responses to this app
      </Text>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#1a1a1a', padding: 20 },
  header: { marginBottom: 24 },
  title: { fontSize: 24, fontWeight: 'bold', color: '#fff' },
  subtitle: { fontSize: 14, color: '#888', marginTop: 4 },
  card: { 
    backgroundColor: '#2a2a2a', 
    padding: 16, 
    borderRadius: 12, 
    marginBottom: 16 
  },
  label: { fontSize: 12, color: '#888', marginBottom: 4, textTransform: 'uppercase' },
  value: { fontSize: 16, color: '#fff', fontWeight: '500' },
  hint: { fontSize: 12, color: '#32CD32', marginTop: 8, fontFamily: 'monospace' },
  appItem: { fontSize: 14, color: '#ddd', marginTop: 8 },
  footer: { fontSize: 12, color: '#666', textAlign: 'center', marginTop: 16 },
});
```

## Phase 2: USB Reverse Tethering Setup

### Android ADB Setup Script (PowerShell)

```powershell
# setup-usb-proxy.ps1
Write-Host "üîß LLM Proxy Bridge - USB Setup" -ForegroundColor Cyan

# Check ADB
if (-not (Get-Command adb -ErrorAction SilentlyContinue)) {
    Write-Host "‚ùå ADB not found. Install Android Platform Tools" -ForegroundColor Red
    exit 1
}

# Check device connection
$devices = adb devices | Select-String "device$"
if (-not $devices) {
    Write-Host "‚ùå No Android device connected" -ForegroundColor Red
    Write-Host "Enable USB Debugging: Settings ‚Üí Developer Options ‚Üí USB Debugging"
    exit 1
}

Write-Host "‚úÖ Device connected" -ForegroundColor Green

# Setup reverse port forwarding
Write-Host "Setting up adb reverse tcp:8080 tcp:8080..." -ForegroundColor Yellow
adb reverse tcp:8080 tcp:8080

if ($LASTEXITCODE -eq 0) {
    Write-Host "‚úÖ Port forwarding active" -ForegroundColor Green
    Write-Host "`nDesktop can now connect to: http://localhost:8080" -ForegroundColor Cyan
    Write-Host "`nTest with: curl http://localhost:8080/health" -ForegroundColor Yellow
} else {
    Write-Host "‚ùå Port forwarding failed" -ForegroundColor Red
}

# Keep alive loop
Write-Host "`nKeeping connection alive... (Ctrl+C to stop)" -ForegroundColor Gray
while ($true) {
    Start-Sleep -Seconds 10
    adb reverse tcp:8080 tcp:8080 | Out-Null
}
```

### Test Desktop Connection (Node.js)

```javascript
// test-connection.js
const axios = require('axios');

async function testConnection() {
  const endpoints = [
    'http://localhost:8080/health',  // USB mode
    'http://192.168.1.100:8080/health'  // WiFi mode (replace IP)
  ];

  for (const url of endpoints) {
    try {
      console.log(`Testing: ${url}`);
      const response = await axios.get(url, { timeout: 3000 });
      console.log('‚úÖ Connected!', response.data);
      return url.replace('/health', '');
    } catch (error) {
      console.log(`‚ùå Failed: ${error.message}`);
    }
  }

  console.error('No connection available. Check USB/WiFi setup.');
}

testConnection();
```

## Immediate Testing Workflow

### Day 1: Share Extension Test

```bash
# 1. Build dev client (required for share extension)
npx expo install expo-dev-client
npx expo prebuild
npx expo run:android  # or run:ios

# 2. Test share from Notes app
# - Open Notes, type text, tap Share
# - Should see "LLM Proxy Bridge" in share sheet
# - Tap it, should see "Processing response..."
# - Check console logs for "Received share: ..."
```

### Day 2: HTTP Server Test

```bash
# 1. Start Expo app on phone
npx expo start --dev-client

# 2. Note the IP address displayed in app (e.g., 192.168.1.100)

# 3. From desktop, test health endpoint
curl http://192.168.1.100:8080/health
# Should return: {"status":"ok","timestamp":...}

# 4. Send test query
curl -X POST http://192.168.1.100:8080/query \
  -H "Content-Type: application/json" \
  -d '{"appId":"perplexity","prompt":"test query"}'
# Should open Perplexity app on phone
```

### Day 3: USB Mode Test

```bash
# 1. Connect phone via USB
adb devices  # Verify connection

# 2. Run setup script
powershell ./setup-usb-proxy.ps1

# 3. Test via localhost
curl http://localhost:8080/health

# 4. Send query via USB
curl -X POST http://localhost:8080/query \
  -H "Content-Type: application/json" \
  -d '{"appId":"chatgpt","prompt":"Hello world"}'
```

## Quick Wins & Gotchas

**‚úÖ Quick Wins:**
- Share extension appears immediately after dev-client build
- Express server works out-of-box with Expo (no Metro conflicts)
- ADB reverse persists across app restarts

**‚ö†Ô∏è Gotchas:**
- Share extension requires `expo-dev-client` build (not Expo Go)
- iOS requires signing profile for extensions (free Apple Developer account works)
- Android 11+ needs `queries` declaration in AndroidManifest for deep links:

```xml
<!-- android/app/src/main/AndroidManifest.xml -->
<queries>
  <intent>
    <action android:name="android.intent.action.VIEW" />
    <data android:scheme="perplexity" />
  </intent>
  <!-- Add for each app -->
</queries>
```

Your validated path forward is solid‚Äîstart with the share extension test today, then layer in USB and mDNS. Let me know when you hit the first successful share capture! üöÄ

