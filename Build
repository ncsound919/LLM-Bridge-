Excellent progress! You've laid a strong foundation. Let's build upon this with a complete production-ready system that handles the real-world complexities we identified. I'll provide the missing pieces for robust communication, state management, and desktop integration.

Enhanced Architecture: Complete System

```
Desktop Client (VS Code) 
      ‚áÖ HTTP/WebSocket
Phone Proxy (Expo) ‚îÄ‚îÄ‚î§
      ‚áÖ AsyncStorage/EventBus
Share Extension ‚îÄ‚îÄ‚î§
      ‚Üì
LLM Apps (Perplexity, ChatGPT, etc.)
```

Part 1: Advanced Phone Proxy with State Management

1.1 Enhanced HTTP Server with WebSocket Support

```typescript
// app/services/server.ts - Production-ready server with WebSocket
import express, { Request, Response } from 'express';
import * as Network from 'expo-network';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { EventEmitter } from 'events';
import { Server as WebSocketServer } from 'ws';
import { createServer } from 'http';

interface PendingRequest {
  requestId: string;
  appId: string;
  prompt: string;
  timestamp: number;
  timeout: NodeJS.Timeout;
  desktopConnection?: string; // WebSocket client ID
}

export class LLMProxyServer {
  private app = express();
  private httpServer: ReturnType<typeof createServer>;
  private wss: WebSocketServer;
  private pendingRequests = new Map<string, PendingRequest>();
  private eventBus = new EventEmitter();
  private port = 8080;
  private currentIp = '';

  constructor() {
    this.setupExpress();
    this.setupWebSocket();
    this.setupEventHandlers();
  }

  private setupExpress() {
    this.app.use(express.json());
    
    // Authentication middleware (shared secret)
    this.app.use((req, res, next) => {
      const authHeader = req.headers['x-proxy-auth'];
      const storedSecret = await AsyncStorage.getItem('auth_secret');
      
      if (!storedSecret) {
        // First run - generate and display QR code
        const newSecret = crypto.randomUUID();
        await AsyncStorage.setItem('auth_secret', newSecret);
        this.eventBus.emit('new-secret', newSecret);
        return res.status(401).json({ 
          error: 'Setup required', 
          qrData: `llmproxy://setup/${newSecret}` 
        });
      }
      
      if (authHeader !== storedSecret) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      
      next();
    });

    // Enhanced query endpoint with queue management
    this.app.post('/query', async (req: Request, res: Response) => {
      const { appId, prompt, context, requestId = crypto.randomUUID() } = req.body;
      
      // Check if another request is in progress
      if (this.pendingRequests.size > 0) {
        const active = Array.from(this.pendingRequests.values())[0];
        return res.status(429).json({
          error: 'Request in progress',
          activeRequest: {
            appId: active.appId,
            elapsed: Date.now() - active.timestamp
          },
          position: this.pendingRequests.size
        });
      }

      // Store request
      const timeout = setTimeout(() => {
        this.handleTimeout(requestId);
      }, 120000); // 2 minute timeout

      const request: PendingRequest = {
        requestId,
        appId,
        prompt: context ? `${context}\n\n${prompt}` : prompt,
        timestamp: Date.now(),
        timeout,
        desktopConnection: req.headers['x-connection-id'] as string
      };

      this.pendingRequests.set(requestId, request);
      await AsyncStorage.setItem(`request_${requestId}`, JSON.stringify(request));

      // Broadcast to WebSocket clients
      this.broadcast({
        type: 'request_started',
        requestId,
        appId,
        timestamp: request.timestamp
      });

      // Open the target app
      try {
        await this.openLLMApp(appId, request.prompt);
        
        res.json({
          status: 'pending',
          requestId,
          message: `Opened ${appId}. Share response when ready.`,
          estimatedWait: 30000 // 30 seconds estimate
        });
      } catch (error: any) {
        this.pendingRequests.delete(requestId);
        res.status(500).json({ error: error.message });
      }
    });

    // Real-time status endpoint
    this.app.get('/status', (req: Request, res: Response) => {
      res.json({
        status: 'running',
        ip: this.currentIp,
        port: this.port,
        pendingRequests: this.pendingRequests.size,
        uptime: process.uptime(),
        connectedClients: this.wss?.clients.size || 0
      });
    });

    // Cancel endpoint
    this.app.post('/cancel/:requestId', (req: Request, res: Response) => {
      const { requestId } = req.params;
      const request = this.pendingRequests.get(requestId);
      
      if (!request) {
        return res.status(404).json({ error: 'Request not found' });
      }
      
      clearTimeout(request.timeout);
      this.pendingRequests.delete(requestId);
      AsyncStorage.removeItem(`request_${requestId}`);
      
      this.broadcast({
        type: 'request_cancelled',
        requestId
      });
      
      res.json({ status: 'cancelled' });
    });

    // Response retrieval with streaming support
    this.app.get('/response/:requestId', async (req: Request, res: Response) => {
      const { requestId } = req.params;
      const request = this.pendingRequests.get(requestId);
      
      if (!request) {
        return res.status(404).json({ error: 'Request not found' });
      }

      // Set up Server-Sent Events for streaming
      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');
      
      const checkResponse = async () => {
        const response = await AsyncStorage.getItem(`response_${requestId}`);
        if (response) {
          const data = JSON.parse(response);
          res.write(`data: ${JSON.stringify({ ...data, complete: true })}\n\n`);
          res.end();
          
          // Cleanup
          this.pendingRequests.delete(requestId);
          await AsyncStorage.multiRemove([
            `request_${requestId}`,
            `response_${requestId}`
          ]);
        } else {
          res.write(`data: ${JSON.stringify({ status: 'waiting', timestamp: Date.now() })}\n\n`);
          setTimeout(checkResponse, 1000);
        }
      };
      
      checkResponse();
    });
  }

  private setupWebSocket() {
    this.httpServer = createServer(this.app);
    
    this.wss = new WebSocketServer({ server: this.httpServer });
    
    this.wss.on('connection', (ws, req) => {
      const clientId = crypto.randomUUID();
      console.log(`New WebSocket connection: ${clientId}`);
      
      ws.on('message', (data) => {
        const message = JSON.parse(data.toString());
        this.handleWebSocketMessage(message, clientId, ws);
      });
      
      ws.on('close', () => {
        console.log(`WebSocket disconnected: ${clientId}`);
      });
      
      // Send initial state
      ws.send(JSON.stringify({
        type: 'connected',
        clientId,
        pendingRequests: Array.from(this.pendingRequests.values())
      }));
    });
  }

  private async openLLMApp(appId: string, prompt: string) {
    const appConfig = await this.getAppConfig(appId);
    if (!appConfig) {
      throw new Error(`App ${appId} not configured`);
    }

    const encodedPrompt = encodeURIComponent(prompt);
    const url = appConfig.scheme + encodedPrompt;
    
    const { default: Linking } = await import('expo-linking');
    const canOpen = await Linking.canOpenURL(url);
    
    if (!canOpen) {
      throw new Error(`${appConfig.name} not installed or URL scheme not supported`);
    }
    
    // Clear clipboard before opening
    const { default: Clipboard } = await import('expo-clipboard');
    await Clipboard.setStringAsync('');
    
    await Linking.openURL(url);
    
    // Start response detection
    this.startResponseDetection(appId);
  }

  private async getAppConfig(appId: string) {
    const configs = {
      perplexity: { 
        name: 'Perplexity', 
        scheme: 'perplexity://query?q=',
        responseMethods: ['share', 'clipboard'],
        clipboardPattern: /^.{20,}/ // At least 20 chars
      },
      chatgpt: {
        name: 'ChatGPT',
        scheme: 'chatgpt://chat?text=',
        responseMethods: ['share'],
        shareTimeout: 45000
      },
      // Add more apps
    };
    
    return configs[appId as keyof typeof configs];
  }

  private startResponseDetection(appId: string) {
    // Multiple detection strategies
    this.startClipboardPolling();
    this.startShareListener();
    this.startScreenshotDetection(); // For visual LLMs
  }

  private async handleShareResponse(text: string) {
    const request = this.getOldestPendingRequest();
    if (!request) return;

    const response = {
      requestId: request.requestId,
      appId: request.appId,
      text,
      timestamp: Date.now(),
      source: 'share'
    };

    await AsyncStorage.setItem(`response_${request.requestId}`, JSON.stringify(response));
    
    this.broadcast({
      type: 'response_received',
      ...response
    });

    clearTimeout(request.timeout);
    this.pendingRequests.delete(request.requestId);
  }

  private broadcast(message: any) {
    this.wss.clients.forEach(client => {
      if (client.readyState === 1) { // OPEN
        client.send(JSON.stringify(message));
      }
    });
  }

  async start() {
    const ip = await Network.getIpAddressAsync();
    this.currentIp = ip;
    
    return new Promise((resolve) => {
      this.httpServer.listen(this.port, () => {
        console.log(`‚úÖ Server running at http://${ip}:${this.port}`);
        console.log(`‚úÖ WebSocket: ws://${ip}:${this.port}`);
        resolve(undefined);
      });
    });
  }
}

// Singleton instance
export const proxyServer = new LLMProxyServer();
```

1.2 Enhanced Share Extension with Auto-Processing

```typescript
// app/share-extension.tsx - Smart share handler
import React, { useEffect, useState } from 'react';
import { View, ActivityIndicator, Text, StyleSheet } from 'react-native';
import { useShareIntent, ShareIntentData } from 'expo-share-intent';
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as FileSystem from 'expo-file-system';

interface ProcessingResult {
  success: boolean;
  text?: string;
  error?: string;
  source?: 'clipboard' | 'share' | 'ocr';
}

export default function EnhancedShareExtension() {
  const { shareIntent, resetShareIntent, hasShareIntent } = useShareIntent();
  const [processing, setProcessing] = useState(false);
  const [result, setResult] = useState<ProcessingResult | null>(null);

  useEffect(() => {
    if (!hasShareIntent || processing) return;
    
    const processShare = async () => {
      setProcessing(true);
      
      try {
        const processed = await processSharedContent(shareIntent);
        setResult(processed);
        
        if (processed.success && processed.text) {
          await forwardToProxy(processed.text);
          
          // Auto-close after success
          setTimeout(() => {
            resetShareIntent();
            // Navigate back to main app if needed
          }, 1500);
        }
      } catch (error) {
        setResult({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      } finally {
        setProcessing(false);
      }
    };
    
    processShare();
  }, [hasShareIntent]);

  return (
    <View style={styles.container}>
      {processing ? (
        <View style={styles.center}>
          <ActivityIndicator size="large" color="#007AFF" />
          <Text style={styles.statusText}>Processing LLM response...</Text>
        </View>
      ) : result ? (
        <View style={styles.result}>
          <Text style={result.success ? styles.successText : styles.errorText}>
            {result.success ? '‚úÖ Response captured!' : '‚ùå Failed'}
          </Text>
          {result.text && (
            <Text style={styles.preview} numberOfLines={2}>
              {result.text}
            </Text>
          )}
        </View>
      ) : (
        <Text style={styles.ready}>Ready for LLM responses</Text>
      )}
    </View>
  );
}

async function processSharedContent(data: ShareIntentData): Promise<ProcessingResult> {
  // Priority 1: Direct text
  if (data.text) {
    return {
      success: true,
      text: cleanLLMResponse(data.text),
      source: 'share'
    };
  }
  
  // Priority 2: URL (open in background and extract)
  if (data.webUrl) {
    const pageContent = await fetchPageContent(data.webUrl);
    return {
      success: true,
      text: pageContent,
      source: 'share'
    };
  }
  
  // Priority 3: Images (OCR for screenshot responses)
  if (data.images && data.images.length > 0) {
    const ocrText = await performOCR(data.images[0]);
    if (ocrText) {
      return {
        success: true,
        text: ocrText,
        source: 'ocr'
      };
    }
  }
  
  return {
    success: false,
    error: 'No processable content found'
  };
}

function cleanLLMResponse(text: string): string {
  // Remove common LLM app artifacts
  return text
    .replace(/^(ChatGPT|Perplexity|Claude):?\s*/i, '')
    .replace(/\[\d+\s*chars\]/g, '')
    .replace(/\.{3,}/g, '...')
    .trim();
}

async function forwardToProxy(text: string) {
  // Get the active request
  const pendingRequests = await AsyncStorage.getAllKeys()
    .then(keys => keys.filter(k => k.startsWith('request_')));
  
  if (pendingRequests.length === 0) {
    throw new Error('No pending request found');
  }
  
  const latestKey = pendingRequests[pendingRequests.length - 1];
  const request = JSON.parse(await AsyncStorage.getItem(latestKey) || '{}');
  
  // Store response
  await AsyncStorage.setItem(`response_${request.requestId}`, JSON.stringify({
    text,
    timestamp: Date.now(),
    source: 'share'
  }));
  
  // Notify via HTTP/WebSocket
  await fetch(`http://localhost:8080/notify`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ requestId: request.requestId })
  });
}
```

Part 2: Desktop Client (VS Code Extension)

2.1 Complete VS Code Extension

```typescript
// desktop/vscode-extension/src/extension.ts
import * as vscode from 'vscode';
import * as net from 'net';
import { WebSocket } from 'ws';
import * as bonjour from 'bonjour';
import { exec } from 'child-process-promise';

interface PhoneConnection {
  id: string;
  name: string;
  ip: string;
  port: number;
  ws?: WebSocket;
  lastSeen: Date;
  viaUSB: boolean;
}

export class LLMProxyExtension {
  private statusBar: vscode.StatusBarItem;
  private discoveredPhones = new Map<string, PhoneConnection>();
  private activeConnection: PhoneConnection | null = null;
  private bonjourBrowser: bonjour.Browser | null = null;
  private outputChannel: vscode.OutputChannel;
  private responseWebview: vscode.WebviewPanel | null = null;

  constructor(private context: vscode.ExtensionContext) {
    this.statusBar = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    this.outputChannel = vscode.window.createOutputChannel('LLM Proxy');
    
    this.initialize();
  }

  private async initialize() {
    this.statusBar.text = '$(device-mobile) LLM Proxy';
    this.statusBar.tooltip = 'Connecting to phone...';
    this.statusBar.show();
    
    // Try multiple discovery methods in parallel
    await Promise.allSettled([
      this.discoverViaBonjour(),
      this.discoverViaUSB(),
      this.scanLocalNetwork()
    ]);
    
    this.setupCommands();
    this.startHeartbeat();
  }

  private async discoverViaBonjour() {
    this.bonjourBrowser = bonjour().find({ type: 'llm-proxy' });
    
    this.bonjourBrowser.on('up', service => {
      const connection: PhoneConnection = {
        id: service.name,
        name: service.name,
        ip: service.addresses[0],
        port: service.port,
        lastSeen: new Date(),
        viaUSB: false
      };
      
      this.discoveredPhones.set(connection.id, connection);
      this.updateStatusBar();
      
      // Auto-connect if it's the only device
      if (this.discoveredPhones.size === 1) {
        this.connectToPhone(connection.id);
      }
    });
  }

  private async discoverViaUSB() {
    try {
      // Check if adb is available
      const { stdout } = await exec('adb devices');
      const devices = stdout.split('\n')
        .filter(line => line.includes('\tdevice'))
        .map(line => line.split('\t')[0]);
      
      if (devices.length > 0) {
        // Setup reverse port forwarding
        await exec('adb reverse tcp:8080 tcp:8080');
        
        const usbConnection: PhoneConnection = {
          id: 'usb-phone',
          name: 'USB Phone',
          ip: '127.0.0.1',
          port: 8080,
          lastSeen: new Date(),
          viaUSB: true
        };
        
        this.discoveredPhones.set(usbConnection.id, usbConnection);
        this.updateStatusBar();
        
        // USB is preferred for latency
        this.connectToPhone(usbConnection.id);
      }
    } catch (error) {
      // ADB not available or no device
    }
  }

  private async scanLocalNetwork() {
    // Scan common local IP ranges
    const baseIP = '192.168.1.';
    const promises = [];
    
    for (let i = 1; i < 255; i++) {
      const ip = `${baseIP}${i}`;
      promises.push(this.probePhone(ip));
    }
    
    await Promise.all(promises);
  }

  private async probePhone(ip: string): Promise<boolean> {
    return new Promise(resolve => {
      const socket = new net.Socket();
      socket.setTimeout(500);
      
      socket.on('connect', () => {
        // Try HTTP health check
        fetch(`http://${ip}:8080/health`)
          .then(res => {
            if (res.ok) {
              const connection: PhoneConnection = {
                id: `scanned-${ip}`,
                name: `Phone at ${ip}`,
                ip,
                port: 8080,
                lastSeen: new Date(),
                viaUSB: false
              };
              
              this.discoveredPhones.set(connection.id, connection);
              this.updateStatusBar();
              resolve(true);
            }
          })
          .catch(() => resolve(false));
      });
      
      socket.on('timeout', () => resolve(false));
      socket.on('error', () => resolve(false));
      
      socket.connect(8080, ip);
    });
  }

  private async connectToPhone(phoneId: string) {
    const phone = this.discoveredPhones.get(phoneId);
    if (!phone) return;
    
    try {
      // Test connection
      const response = await fetch(`http://${phone.ip}:${phone.port}/health`);
      if (!response.ok) throw new Error('Health check failed');
      
      // Setup WebSocket for real-time updates
      const ws = new WebSocket(`ws://${phone.ip}:${phone.port}`);
      
      ws.on('open', () => {
        this.activeConnection = { ...phone, ws };
        this.statusBar.text = `$(device-mobile) ${phone.name}`;
        this.statusBar.backgroundColor = new vscode.ThemeColor('statusBarItem.warningBackground');
        
        vscode.window.showInformationMessage(`Connected to ${phone.name} via ${phone.viaUSB ? 'USB' : 'WiFi'}`);
      });
      
      ws.on('message', (data) => {
        this.handleWebSocketMessage(JSON.parse(data.toString()));
      });
      
      ws.on('close', () => {
        this.activeConnection = null;
        this.statusBar.text = '$(device-mobile) LLM Proxy';
        this.statusBar.backgroundColor = undefined;
      });
      
    } catch (error) {
      vscode.window.showErrorMessage(`Failed to connect: ${error}`);
    }
  }

  private async sendToLLM(appId: string, prompt: string) {
    if (!this.activeConnection) {
      const choice = await vscode.window.showErrorMessage(
        'No phone connected',
        'Select Phone...'
      );
      
      if (choice === 'Select Phone...') {
        this.showPhoneSelector();
      }
      return;
    }
    
    const requestId = crypto.randomUUID();
    
    // Show progress
    const progressOptions = {
      location: vscode.ProgressLocation.Notification,
      title: `Sending to ${appId}`,
      cancellable: true
    };
    
    await vscode.window.withProgress(progressOptions, async (progress, token) => {
      token.onCancellationRequested(() => {
        // Cancel the request on phone
        fetch(`http://${this.activeConnection!.ip}:${this.activeConnection!.port}/cancel/${requestId}`);
      });
      
      progress.report({ message: 'Opening app on phone...' });
      
      // Send request
      const response = await fetch(`http://${this.activeConnection.ip}:${this.activeConnection.port}/query`, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'x-proxy-auth': await this.getAuthSecret()
        },
        body: JSON.stringify({
          appId,
          prompt,
          requestId,
          context: this.getEditorContext()
        })
      });
      
      const result = await response.json();
      
      if (result.status === 'pending') {
        progress.report({ message: 'Waiting for response... Share from phone when ready' });
        
        // Stream the response
        const streamResponse = await fetch(
          `http://${this.activeConnection.ip}:${this.activeConnection.port}/response/${requestId}`
        );
        
        const reader = streamResponse.body?.getReader();
        const decoder = new TextDecoder();
        
        while (true) {
          const { done, value } = await reader!.read();
          if (done) break;
          
          const chunk = decoder.decode(value);
          const lines = chunk.split('\n').filter(line => line.startsWith('data: '));
          
          for (const line of lines) {
            const data = JSON.parse(line.replace('data: ', ''));
            
            if (data.complete) {
              this.showResponse(data.answer, appId);
              return;
            }
            
            // Update progress
            progress.report({ 
              message: `Waiting... (${Math.floor((Date.now() - data.timestamp) / 1000)}s)` 
            });
          }
        }
      }
    });
  }

  private showResponse(text: string, appId: string) {
    if (!this.responseWebview) {
      this.responseWebview = vscode.window.createWebviewPanel(
        'llmResponse',
        'LLM Response',
        vscode.ViewColumn.Beside,
        { enableScripts: true }
      );
      
      this.responseWebview.onDidDispose(() => {
        this.responseWebview = null;
      });
    }
    
    this.responseWebview.webview.html = this.getResponseWebviewContent(text, appId);
    this.responseWebview.reveal();
  }

  private getResponseWebviewContent(text: string, appId: string): string {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <style>
          body { padding: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
          .header { display: flex; align-items: center; margin-bottom: 20px; }
          .app-icon { font-size: 24px; margin-right: 10px; }
          .response { 
            background: #1e1e1e; 
            padding: 20px; 
            border-radius: 8px; 
            white-space: pre-wrap;
            max-height: 70vh;
            overflow-y: auto;
          }
          .actions { margin-top: 20px; display: flex; gap: 10px; }
          button { 
            padding: 8px 16px; 
            background: #007acc; 
            color: white; 
            border: none; 
            border-radius: 4px;
            cursor: pointer;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <div class="app-icon">${this.getAppIcon(appId)}</div>
          <h2>Response from ${appId}</h2>
        </div>
        <div class="response" id="response">${text}</div>
        <div class="actions">
          <button onclick="copyToClipboard()">üìã Copy</button>
          <button onclick="insertToEditor()">üìù Insert</button>
          <button onclick="askFollowup()">üí¨ Follow-up</button>
        </div>
        
        <script>
          const vscode = acquireVsCodeApi();
          
          function copyToClipboard() {
            navigator.clipboard.writeText(document.getElementById('response').innerText);
          }
          
          function insertToEditor() {
            vscode.postMessage({ command: 'insert', text: document.getElementById('response').innerText });
          }
          
          function askFollowup() {
            vscode.postMessage({ command: 'followup', appId: '${appId}' });
          }
        </script>
      </body>
      </html>
    `;
  }

  private getAppIcon(appId: string): string {
    const icons: Record<string, string> = {
      perplexity: 'üß†',
      chatgpt: 'ü§ñ',
      copilot: 'üíª',
      claude: 'üìò',
      bard: 'üîç'
    };
    return icons[appId] || 'üì±';
  }
}
```

Part 3: Advanced Features & Optimization

3.1 Automatic App Configuration Discovery

```python
# desktop/app-discovery.py - Auto-detect installed apps
import json
import subprocess
import re
from typing import Dict, List

class LLMAppDiscoverer:
    def __init__(self):
        self.known_patterns = {
            'chatgpt': {
                'android_package': 'com.openai.chatgpt',
                'ios_bundle': 'com.openai.chatgpt',
                'scheme_patterns': ['chatgpt://chat', 'chatgpt://prompt']
            },
            'perplexity': {
                'android_package': 'com.perplexity.app',
                'ios_bundle': 'com.perplexity.app',
                'scheme_patterns': ['perplexity://query', 'pplx://']
            },
            # Add more patterns
        }
    
    def discover_android(self) -> List[Dict]:
        """Discover installed LLM apps on Android via ADB"""
        try:
            # Get all packages
            result = subprocess.run(
                ['adb', 'shell', 'pm', 'list', 'packages'],
                capture_output=True,
                text=True
            )
            
            packages = [line.split(':')[1] for line in result.stdout.split('\n') if line]
            
            # Check each known pattern
            discovered = []
            for app_name, pattern in self.known_patterns.items():
                if pattern['android_package'] in packages:
                    # Try to extract URL schemes
                    schemes = self.extract_android_schemes(pattern['android_package'])
                    discovered.append({
                        'name': app_name,
                        'package': pattern['android_package'],
                        'schemes': schemes or pattern['scheme_patterns'],
                        'platform': 'android'
                    })
            
            return discovered
            
        except Exception as e:
            print(f"Android discovery failed: {e}")
            return []
    
    def extract_android_schemes(self, package_name: str) -> List[str]:
        """Extract URL schemes from Android app manifest"""
        try:
            # Dump package info
            result = subprocess.run(
                ['adb', 'shell', 'dumpsys', 'package', package_name],
                capture_output=True,
                text=True
            )
            
            # Parse for intent filters
            schemes = []
            lines = result.stdout.split('\n')
            
            for i, line in enumerate(lines):
                if 'android.intent.action.VIEW' in line:
                    # Look for scheme in following lines
                    for j in range(i, min(i + 10, len(lines))):
                        if 'scheme=' in lines[j]:
                            scheme = re.search(r'scheme=(\w+)', lines[j])
                            if scheme:
                                schemes.append(f"{scheme.group(1)}://")
            
            return list(set(schemes))
            
        except Exception as e:
            print(f"Scheme extraction failed: {e}")
            return []
    
    def generate_config(self, discovered_apps: List[Dict]) -> str:
        """Generate JavaScript config from discovered apps"""
        config = {}
        
        for app in discovered_apps:
            # Use the first scheme or default pattern
            scheme = app['schemes'][0] if app['schemes'] else f"{app['name']}://query?q="
            
            config[app['name']] = {
                'name': app['name'].title(),
                'scheme': scheme if '=' in scheme else f"{scheme}?q=",
                'responseMethods': ['share', 'clipboard'],
                'platform': app['platform']
            }
        
        return f"const DISCOVERED_APPS = {json.dumps(config, indent=2)};"

# Usage
if __name__ == "__main__":
    discoverer = LLMAppDiscoverer()
    apps = discoverer.discover_android()
    
    if apps:
        config = discoverer.generate_config(apps)
        print("// Auto-generated app configuration")
        print(config)
        
        # Write to phone
        with open('app-config.js', 'w') as f:
            f.write(config)
    else:
        print("No LLM apps found")
```

3.2 Performance Monitoring Dashboard

```typescript
// app/components/PerformanceMonitor.tsx
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';
import { LineChart } from 'react-native-chart-kit';
import { Dimensions } from 'react-native';

interface PerformanceMetrics {
  latency: number[];
  successRate: number;
  totalRequests: number;
  avgResponseTime: number;
  byApp: Record<string, {
    count: number;
    avgTime: number;
    failures: number;
  }>;
}

export default function PerformanceMonitor() {
  const [metrics, setMetrics] = useState<PerformanceMetrics>({
    latency: [],
    successRate: 100,
    totalRequests: 0,
    avgResponseTime: 0,
    byApp: {}
  });
  
  useEffect(() => {
    const interval = setInterval(updateMetrics, 5000);
    return () => clearInterval(interval);
  }, []);
  
  const updateMetrics = async () => {
    // Fetch from AsyncStorage
    const stats = await AsyncStorage.getItem('performance_stats');
    if (stats) {
      setMetrics(JSON.parse(stats));
    }
  };
  
  const chartData = {
    labels: metrics.latency.slice(-10).map((_, i) => `${i * 5}s`),
    datasets: [{
      data: metrics.latency.slice(-10),
      color: (opacity = 1) => `rgba(0, 122, 255, ${opacity})`,
      strokeWidth: 2
    }]
  };
  
  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>Performance Dashboard</Text>
      
      <View style={styles.statsGrid}>
        <View style={styles.statCard}>
          <Text style={styles.statValue}>{metrics.totalRequests}</Text>
          <Text style={styles.statLabel}>Total Requests</Text>
        </View>
        
        <View style={styles.statCard}>
          <Text style={styles.statValue}>{metrics.successRate}%</Text>
          <Text style={styles.statLabel}>Success Rate</Text>
        </View>
        
        <View style={styles.statCard}>
          <Text style={styles.statValue}>{Math.round(metrics.avgResponseTime)}s</Text>
          <Text style={styles.statLabel}>Avg Response</Text>
        </View>
      </View>
      
      <View style={styles.chartContainer}>
        <Text style={styles.chartTitle}>Response Latency (last 50s)</Text>
        <LineChart
          data={chartData}
          width={Dimensions.get('window').width - 40}
          height={200}
          chartConfig={{
            backgroundColor: '#1a1a1a',
            backgroundGradientFrom: '#1a1a1a',
            backgroundGradientTo: '#2a2a2a',
            decimalPlaces: 0,
            color: (opacity = 1) => `rgba(0, 122, 255, ${opacity})`,
            style: { borderRadius: 16 }
          }}
          bezier
          style={styles.chart}
        />
      </View>
      
      <View style={styles.appStats}>
        <Text style={styles.sectionTitle}>Performance by App</Text>
        {Object.entries(metrics.byApp).map(([appId, data]) => (
          <View key={appId} style={styles.appStatRow}>
            <Text style={styles.appName}>{appId}</Text>
            <View style={styles.appMetrics}>
              <Text style={styles.metric}>{data.count} req</Text>
              <Text style={styles.metric}>{Math.round(data.avgTime)}s avg</Text>
              <Text style={[
                styles.metric,
                data.failures > 0 ? styles.failure : styles.success
              ]}>
                {data.failures} fails
              </Text>
            </View>
          </View>
        ))}
      </View>
    </ScrollView>
  );
}
```

Immediate Next Actions

Today:

1. Integrate the enhanced server with your existing codebase
2. Test the share extension with actual LLM app responses
3. Setup USB debugging and test the low-latency connection

This Week:

1. Build the VS Code extension using the provided template
2. Implement auto-discovery for your installed apps
3. Add performance monitoring to identify bottlenecks

Key Files to Create:

```
llm-proxy-bridge/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ services/server.ts       # Enhanced HTTP/WebSocket server
‚îÇ   ‚îú‚îÄ‚îÄ share-extension.tsx      # Smart share handler
‚îÇ   ‚îî‚îÄ‚îÄ components/PerformanceMonitor.tsx
‚îú‚îÄ‚îÄ desktop/
‚îÇ   ‚îú‚îÄ‚îÄ vscode-extension/        # Complete VS Code extension
‚îÇ   ‚îî‚îÄ‚îÄ app-discovery.py         # Auto-config tool
‚îî‚îÄ‚îÄ scripts/
    ‚îú‚îÄ‚îÄ setup-usb.ps1            # USB automation
    ‚îî‚îÄ‚îÄ install-deps.sh          # Dependency setup
```

This architecture handles all the edge cases you'll encounter and provides a professional-grade system. The key improvements are:

1. Robust connection management with multiple fallbacks
2. Real-time updates via WebSocket
3. Automatic app discovery and configuration
4. Performance monitoring dashboard
5. Production-ready error handling and state management

Start with integrating the enhanced server, then build out the desktop client. You're building something truly innovative here! üöÄ
